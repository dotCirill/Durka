!!! Где
    Вирт, структуры данных 1989. Примерно 840 страница.

**Ассоциативные массивы** -- массивы, в которых для обращения к элементам используются ключи, логически связанные со значениями.

## Хеш-функции

Основным требованием к хорошей хеш-функции является наиболее равномерное из возможных распределение ключей по диапозону значений индексов. Кроме выполнения этого требования, распределение не связано никакой схемой, даже желательно, чтобы оно производило впечатление совершенно случайного.

Предположим, что имеется функция $ord(k)$, которая определяет порядковый номер ключа $k$ во множестве всевозможных ключей. Предположим также, что индексы массива лежат в интервале $[0;\; N-1]$, где $N$ -- размер массива. Тогда очевидно, что нужно выбрать следующую функцию: $H(k) = ord(k) \mod N$. Для неё характерно равномерное распределение клюей. Кроме того, она очень эффективно вычисляется при $N$, равном степени двойки. Но как раз этого случая надо избегать, если ключи являются последовательностями букв (легко подобрать разные слова с одинаковыми значениями хеш-функций).

$N$ данных A[n]. $x$ -- ключ. Необходимо найти ключ по индексу.

Хеш-фунция $f: X \rightarrow I$ должна иметь следующие свойства:

1. Быть быстрой
2. Быть равномерной (чтобы разные ключи преобразовывались в разные индексы).
3. $X$ -- большая (бесконечная) размерность, $I$ -- фиксированная размерность (помещается в массив).

**Хеш-функция** -- функция, которая переводит аргумент любой размерности в результат фиксированной размерности.

Ситуацию, когда два разных ключа имеют один и тот же индекс называется **конфликтом** или **коллизией**.

## Решение коллизий

Существует два решения:

1. Там, где коллизия - устраиваем линейный список/массив. Однако это может свести на нет преимущества поиска с использованием хэширования. Способ называется прямое связование/линейные пробы.
2. Записываем этот элемент в следующую ячейку (если и там что-то есть, то снова идем следующую и тд.). Называется открытой адрессацией.

Во втором решении можно идти не только на следующую ячейку (использовать линейную функцию), но и использовать другие функции (например квадратичную зависимость), но это приводит к слишком большим затратам (Вирт, 840 страница).

В первом способе часто многие ячейки таблицы остаются пустыми.

На странице 847 Вирт показывает (для второго способа) зависимость среднего числа попыток в зависимости от коэффициента заполнения (отношение занятой памяти ко всей памяти), при коэффициенте заполнения $a = 0.99$, среднее число попыток $E = 4.66$ (ну мало короче). До этого Вирт это доказывает.

Недостатки второго способа:

1. Операций всего две: поиск и вставка, удаление вообще говоря не определено.
2. Размер хеш таблицы фиксирован.